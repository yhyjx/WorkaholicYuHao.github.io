# 游览器工作原理及 V8 引擎

## 访问 URL 的过程

- 域名解析
- DNS 预解析获取对应的服务器 IP 地址
- TCP 三次握手
- HTTP 请求发送
- HTTP 响应请求
- 游览器拿到响应资源后通过游览器内核开始渲染
- TCP 四次挥手

## 游览器渲染过程

**游览器引擎**再拿到资源后会开始进行渲染，步骤如下：

- 解析 html 生成 DOMTree （**解析过程中遇到 script 标签怎么办**）
- 解析 css 生成 CSSOMTree
- 将 DOMTree 和 CSSOMTree 组合产生 renderTree
- renderTree 经过布局引擎计算对应的像素点
- GPU 根据像素点绘制界面

### **解析过程中遇到 script 标签怎么办**

默认情况下，html 解析遇到 script 标签会被阻塞，只有下载并执行脚本后才能继续解析。

影响 script 的两个属性

- defer：不会阻塞 html 解析只下载脚本，当 html 解析后再执行脚本
- async：html 解析的过程中下载脚本，下载完会执行可能会影响 html 解析

## JavaScript 引擎

JavaScript 是一门高级语言，机器是不能直接识别的，需要通过 JavaScript 引擎转换为机器语言后让 CPU 执行。

### V8 引擎的原理

- 通过 Parse 解析生成 AST 抽象语法树
  - 游览器内核将源码交给 V8 引擎，Stream 获取到源码后进行编码转换
  - **词法分析**：Scanner 进行词法分析，将代码分词，最终拆分为 tokens（数组）
  - **语法分析**：分析每一个 tokens 的语法是否正确，经过两个步骤
    - Parser：直接将 tokens 转换为 AST 语法树
    - PreParser：预解析，在项目开始阶段对所有 JavaScript 代码进行解析会影响网页的运行效率，V8 引擎实现了将不必要的函数进行预解析，只解析暂时需要的内容，等到函数调用时就会对函数进行全量解析
  - 可以通过 [AST 在线生成](https://astexplorer.net/) 查看对应代码生成的语法树
- 通过 Ignition 将 AST 转为字节码（因为操作系统不一致，所以不能直接转为机器码）
  - 将字节码转换为汇编指令，再由汇编指令转为机器指令，最终被 CPU 执行
  - 字节码是多品台兼容的，只需要不同操作系统切换不同指令即可

> V8 引擎优化
> 如果每次都需要 字节码 —> 汇编指令 —> 机器指令的过程是很耗性能的，所以 V8 通过 TurboFan 库做出如下优化
>
> - TurboFan 库的原理是通过 Ignition 在执行过程中收集信息（比如类型改变），将多次使用的函数标记为**热点函数**直接编译为机器指令，以后使用该函数时直接执行机器指令
> - 但是此时函数的参数类型不能随意改变，改变就要重新进行编译指令，通过 Deopimization 转为字节码，再由字节码转为机器指令

[![V8引擎原理](https://s1.ax1x.com/2023/04/10/ppqkYSf.png)](https://imgse.com/i/ppqkYSf)

[![V8 官方解析过程](https://s1.ax1x.com/2023/04/10/ppqVWnS.png)](https://imgse.com/i/ppqVWnS)

## JavaScript 代码执行过程

要想了解 JavaScript 的运行机制，首先需要掌握两个概念 **执行上下文** 和 **执行栈**。

#### 执行上下文（Execution Context 简称 EC）

JavaScript 是单线程的，代码执行需要一个全局执行环境（上下文），之后每调用一个函数会创建一个新的函数执行上下文。

- **全局执行上下文**：有且只有一个，代码执行前创建
- **函数执行上下文**：执行一个函数前就会创建一个
- eval：运行在 eval 中的代码

> 全局执行上下文和函数执行上下文的区别：
>
> 1. 全局执行上下文只有一个，函数执行上下文有多个。
> 2. 函数执行上下文一般在函数执行后就会销毁，全局执行上下文只有页面关闭才会销毁。

#### 执行栈（Context Stack 简称 CS）

用于存储执行上下文，遵循先入后出的原则。

#### JavaScript 运行机制

- **编译阶段**，首先会创建一个**全局词法环境 （Global Object 简称 GO）**
  - 此时全局作用域创建，可以全局访问
  - 该环境包括 Date、Array 等内置类
- **执行代码**，为了代码正常执行创建了一个全局执行上下文放入到执行栈中
  - 执行上下文的创建：
    - 创建了**词法环境**：
      - 创建了环境记录器：存储 let 、const、函数声明等
      - 创建了外部环境引用：全局执行上下文为 null 、函数执行上下文为词法作用域
    - 创建了**变量环境**：
      - 创建了环境记录器：存储 var 声明的变量及函数声明，函数执行上下文内会存在一个 arguments 对象存在（**变量提升**）
      - 创建了外部环境引用：同上
    - 确认了 this 指向
  - 执行上下文的执行：
    - 对变量赋值/执行函数

[![JavaScript 运行机制](https://s1.ax1x.com/2023/04/13/ppva69H.png)](https://imgse.com/i/ppva69H)

[![JavaScript执行详细过程](https://s1.ax1x.com/2023/04/13/ppvtl7D.png)](https://imgse.com/i/ppvtl7D)

#### 作用域

JavaScript 引擎负责整个程序的编译和运行，其中编译器负责语法分析和代码生成，作用域负责收集并维护声明的标识符号/变量组成的一系列查询，并拥有一套严格的规则确定当前执行代码所查询的条件。

##### 引擎进行变量查询时的类型

- **LHS查询**：赋值操作的目的是谁
- **RHS查询**：谁是赋值操作的源头

> 变量赋值的操作可以分为两个动作
>
> 1. 执行前，编译器会在当前作用域中声明一个变量（如果之前没有声明过）默认 undefined
> 2. 执行时，引擎会在作用域中查找，如果找到进行赋值否则抛出异常

##### 作用域嵌套及查找规则

当一个块/函数在另一个块/函数中，就产生了作用域的嵌套。

**查找规则**

引擎从当前的作用域中开始查找变量，如果找不到就向上查找，直到全局作用域，找到即返回否则抛出异常。

##### 常见异常

1. 如果 RHS 查询所属作用域找不到结果，引擎抛出 ReferenceError 
2. 非严格模式下使用 LHS 查询，如果全局作用域下也没有找到该变量那会在全局作用下新建一个该变量并返回给引擎，严格模式下会抛出 ReferenceError
3. ReferenceError 跟作用域查找有关，TypeError 代表了作用域中存在该变量，只是对结果的操作是不合理的

##### 词法作用域和动态作用域

**词法作用域**

词法作用域是一套关于引擎如何查找变量的规则，它的创建过程在代码书写阶段

**词法作用域的过程**

1. 进行词法化，对源代码的字符进行检查，如果是有状态的会赋予单词语义
2. 词法作用域是定义在词法阶段的作用域，即写代码时写在哪里就确定在哪里
3. 作用域查找会在第一个匹配的标识符时停止
4. 全局变量会自动变为全局对象的属性
5. 无论函数在哪里调用如何调用，它的词法作用域由它声明时所在位置决定
6. 词法作用域只查找一级标识符
7. 编译的词法分析阶段基本能知道全部标识符在哪里以及如何声明，从而预判执行过程中如何进行查找

**动态作用域**

动态作用域不关心函数是如何声明的，它只在乎从何处调用，它是在代码运行时确定的

##### 块级作用域

let / const / try…catch / with 产生的

##### 函数作用域

函数的全部变量及参数可以在这个函数范围内复用，函数创建时产生

##### eval 和 with

- **eval**： 可以对一段代码字符串进行演算，在此时可以修改已经存在的词法作用域
- **with**： 本质上是通过一个对象的引用作为作用域处理，将对象的属性作为作用域中的标识符，创建了一个新的词法作用域

> 这两个机制的副作用是引擎无法在编译时对作用域进行优化，使用其中任何方式都会导致代码运行速度变慢！！！

##### 变量/函数提升

代码执行中，引擎会将变量的声明/函数的声明部分提升到代码开头，变量默认为 undefined ，函数声明的优先级高于变量声明，同一个变量只能被声明一次其余会被覆盖。

##### 作用域和执行上下文的区别

- 作用域是静态的一经创建就不会更改，执行上下文是动态的，函数执行上下文执行会就会销毁
- 作用域在代码编写阶段就创建了，比执行上下文要早