# 游览器工作原理及 V8 引擎

## 访问 URL 的过程

- 域名解析
- DNS 预解析获取对应的服务器 IP 地址
- TCP 三次握手
- HTTP 请求发送
- HTTP 响应请求
- 游览器拿到响应资源后通过游览器内核开始渲染
- TCP 四次挥手

## 游览器渲染过程

**游览器引擎**再拿到资源后会开始进行渲染，步骤如下：

- 解析 html 生成 DOMTree （**解析过程中遇到 script 标签怎么办**）
- 解析 css 生成 CSSOMTree
- 将 DOMTree 和 CSSOMTree 组合产生 renderTree
- renderTree 经过布局引擎计算对应的像素点
- GPU 根据像素点绘制界面

### **解析过程中遇到 script 标签怎么办**

默认情况下，html 解析遇到 script 标签会被阻塞，只有下载并执行脚本后才能继续解析。

影响 script 的两个属性

- defer：不会阻塞 html 解析只下载脚本，当 html 解析后再执行脚本
- async：html 解析的过程中下载脚本，下载完会执行可能会影响 html 解析

## JavaScript 引擎

JavaScript 是一门高级语言，机器是不能直接识别的，需要通过 JavaScript 引擎转换为机器语言后让 CPU 执行。

### V8 引擎的原理

- 通过 Parse 解析生成 AST 抽象语法树
  - 游览器内核将源码交给 V8 引擎，Stream 获取到源码后进行编码转换
  - **词法分析**：Scanner 进行词法分析，将代码分词，最终拆分为 tokens（数组）
  - **语法分析**：分析每一个 tokens 的语法是否正确，经过两个步骤
    - Parser：直接将 tokens 转换为 AST 语法树
    - PreParser：预解析，在项目开始阶段对所有 JavaScript 代码进行解析会影响网页的运行效率，V8 引擎实现了将不必要的函数进行预解析，只解析暂时需要的内容，等到函数调用时就会对函数进行全量解析
  - 可以通过 [AST 在线生成](https://astexplorer.net/) 查看对应代码生成的语法树
- 通过 Ignition 将 AST 转为字节码（因为操作系统不一致，所以不能直接转为机器码）
  - 将字节码转换为汇编指令，再由汇编指令转为机器指令，最终被 CPU 执行
  - 字节码是多品台兼容的，只需要不同操作系统切换不同指令即可

> V8 引擎优化
> 如果每次都需要 字节码 —> 汇编指令 —> 机器指令的过程是很耗性能的，所以 V8 通过 TurboFan 库做出如下优化
>
> - TurboFan 库的原理是通过 Ignition 在执行过程中收集信息（比如类型改变），将多次使用的函数标记为**热点函数**直接编译为机器指令，以后使用该函数时直接执行机器指令
> - 但是此时函数的参数类型不能随意改变，改变就要重新进行编译指令，通过 Deopimization 转为字节码，再由字节码转为机器指令

[![V8引擎原理](https://s1.ax1x.com/2023/04/10/ppqkYSf.png)](https://imgse.com/i/ppqkYSf)

[![V8 官方解析过程](https://s1.ax1x.com/2023/04/10/ppqVWnS.png)](https://imgse.com/i/ppqVWnS)

## JavaScript 代码执行过程

要想了解 JavaScript 的运行机制，首先需要掌握两个概念 **执行上下文** 和 **执行栈**。

#### 执行上下文（Execution Context 简称 EC）

JavaScript 是单线程的，代码执行需要一个全局执行环境（上下文），之后每调用一个函数会创建一个新的函数执行上下文。

- **全局执行上下文**：有且只有一个，代码执行前创建
- **函数执行上下文**：执行一个函数前就会创建一个
- eval：运行在 eval 中的代码

> 全局执行上下文和函数执行上下文的区别：
>
> 1. 全局执行上下文只有一个，函数执行上下文有多个。
> 2. 函数执行上下文一般在函数执行后就会销毁，全局执行上下文只有页面关闭才会销毁。

#### 执行栈（Context Stack 简称 CS）

用于存储执行上下文，遵循先入后出的原则。

#### JavaScript 运行机制

- **编译阶段**，首先会创建一个**全局词法环境 （Global Object 简称 GO）**
  - 此时全局作用域创建，可以全局访问
  - 该环境包括 Date、Array 等内置类
- **执行代码**，为了代码正常执行创建了一个全局执行上下文放入到执行栈中
  - 执行上下文的创建：
    - 创建了**词法环境**：
      - 创建了环境记录器：存储 let 、const、函数声明等
      - 创建了外部环境引用：全局执行上下文为 null 、函数执行上下文为词法作用域
    - 创建了**变量环境**：
      - 创建了环境记录器：存储 var 声明的变量及函数声明，函数执行上下文内会存在一个 arguments 对象（存在**变量提升**）
      - 创建了外部环境引用：同上
    - 确认了 this 指向
  - 执行上下文的执行：
    - 对变量赋值/执行函数
